package com.dbs.c2e.mstd.routing;

import com.dbs.c2e.mstd.config.GapiOrchestrator;
import com.dbs.c2e.mstd.util.GapiRouterUtils;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.HttpHeaders;
import org.springframework.http.server.ServletServerHttpRequest;
import org.springframework.stereotype.Component;
import org.springframework.util.AntPathMatcher;
import org.springframework.web.servlet.HandlerInterceptor;

import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;

@Component
@Slf4j
@RequiredArgsConstructor
public class RoutingHeaderInterceptor implements HandlerInterceptor {

    private final GapiRouterUtils routerUtils;
    private final GapiOrchestrator orchestrator;
    private final AntPathMatcher pathMatcher = new AntPathMatcher();

    @Override
    public boolean preHandle(HttpServletRequest req, HttpServletResponse res, Object handler) {

        // Resolve API config key for this request
        String uri = req.getRequestURI();
        String apiConfig = resolveApiConfig(uri);

        // Fallback to URI if not found (optional)
        if (apiConfig == null) {
            apiConfig = uri;
        }

        // Extract headers
        HttpHeaders headers = new ServletServerHttpRequest(req).getHeaders();

        // This will ALWAYS print routing headers, and only validate when enabled
        routerUtils.checkRoutingHeaders(apiConfig, headers);

        return true;
    }

    private String resolveApiConfig(String uri) {
        return orchestrator.getApiList().keySet().stream()
                .filter(pattern -> pathMatcher.match(pattern, uri))
                .findFirst()
                .orElse(null);
    }
}





package com.dbs.c2e.mstd.routing;

import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Configuration;
import org.springframework.web.servlet.config.annotation.InterceptorRegistry;
import org.springframework.web.servlet.config.annotation.WebMvcConfigurer;

@Configuration
@RequiredArgsConstructor
public class WebMvcConfig implements WebMvcConfigurer {

    private final RoutingHeaderInterceptor routingHeaderInterceptor;

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        registry.addInterceptor(routingHeaderInterceptor)
                .addPathPatterns("/**")                 // apply to all APIs
                .excludePathPatterns("/actuator/**",    // optional excludes
                                     "/health",
                                     "/error");
    }
}




apiList:
   /api/v1/foo:
       routing-headers-enabled: true
   /api/v1/bar:
       routing-headers-enabled: false



@Override
public boolean preHandle(HttpServletRequest req, HttpServletResponse res, Object handler) {
    String apiConfig = resolveApiConfig(req.getRequestURI());
    HttpHeaders headers = new ServletServerHttpRequest(req).getHeaders();
    try {
        routerUtils.checkRoutingHeaders(apiConfig, headers); // prints + (maybe) validates
        return true;
    } catch (GapiValidationException ex) {
        // Use your library’s existing error builder
        ErrorResponse.writeHeaderError(res, ex.getRestApiResponse(), /*status*/400);
        return false; // stops the request here; controller won’t run
    }
}


