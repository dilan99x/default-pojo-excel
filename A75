// 1a) Try to resolve using the mapping’s pointer, but relative to the current context row.
//     Falls back to the absolute pointer if needed.
private String extractByPointerRelative(JsonNode contextNode, String pointer) {
    if (contextNode == null || StringUtils.isBlank(pointer)) return null;

    // If the pointer has wildcards, use only the suffix *after the last "/*"
    if (pointer.contains("/*")) {
        int last = pointer.lastIndexOf("/*");
        String suffix = pointer.substring(last + 2); // e.g. "/pnsProductCode"
        JsonNode n = contextNode.at(suffix);
        if (n != null && !n.isMissingNode() && !n.isNull()) {
            return n.asText();
        }
        // fallback: try the absolute pointer (works when transformer runs at root)
        n = contextNode.at(pointer);
        return (n == null || n.isMissingNode() || n.isNull()) ? null : n.asText();
    }

    // No wildcards — just use the pointer as-is
    JsonNode n = contextNode.at(pointer);
    return (n == null || n.isMissingNode() || n.isNull()) ? null : n.asText();
}

// 1b) Robust DFS lookup by key name anywhere under the current context (works for arrays, nested objects).
private String findFirstTextByKey(JsonNode node, String key) {
    if (node == null || node.isNull() || StringUtils.isBlank(key)) return null;

    if (node.isObject()) {
        JsonNode direct = node.get(key);
        if (direct != null && !direct.isNull() && !direct.isMissingNode()) {
            return direct.asText();
        }
        var fields = node.fields();
        while (fields.hasNext()) {
            Map.Entry<String, JsonNode> e = fields.next();
            String found = findFirstTextByKey(e.getValue(), key);
            if (found != null) return found;
        }
    } else if (node.isArray()) {
        for (JsonNode child : node) {
            String found = findFirstTextByKey(child, key);
            if (found != null) return found;
        }
    }
    return null;
}
