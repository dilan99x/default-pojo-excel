import com.fasterxml.jackson.core.JsonPointer;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.node.MissingNode;

private static JsonNode resolve(JsonNode root, String path, JsonPointer pointer) {
    if (root == null || path == null || path.isEmpty()) return MissingNode.getInstance();

    // Fast path: delegate to Jackson ONLY if there is NO wildcard
    if (path.startsWith("/") && pointer != null && !path.contains("*")) {
        return root.at(pointer);
    }

    // Manual traversal (supports '/', numeric indices, [idx], and '*' wildcard)
    String p = path.startsWith("/") ? path.substring(1) : path;
    String[] tokens = p.isEmpty() ? new String[0] : p.split("/");
    return resolveFrom(root, tokens, 0);
}

private static JsonNode resolveFrom(JsonNode node, String[] tokens, int pos) {
    if (node == null || node.isMissingNode() || node.isNull()) return MissingNode.getInstance();
    if (pos >= tokens.length) return node;

    String raw = tokens[pos];
    if (raw == null || raw.isEmpty()) return resolveFrom(node, tokens, pos + 1);

    // '*' wildcard: return FIRST successful match across array elements or object fields
    if ("*".equals(raw)) {
        if (node.isArray()) {
            for (JsonNode el : node) {
                JsonNode found = resolveFrom(el, tokens, pos + 1);
                if (!found.isMissingNode() && !found.isNull()) return found;
            }
            return MissingNode.getInstance();
        }
        if (node.isObject()) {
            var it = node.fields();
            while (it.hasNext()) {
                JsonNode val = it.next().getValue();
                JsonNode found = resolveFrom(val, tokens, pos + 1);
                if (!found.isMissingNode() && !found.isNull()) return found;
            }
            return MissingNode.getInstance();
        }
        return MissingNode.getInstance();
    }

    // If current node is an array and token is a numeric index like "0"
    if (node.isArray() && isInteger(raw)) {
        int idx = Integer.parseInt(raw);
        if (idx < 0 || idx >= node.size()) return MissingNode.getInstance();
        return resolveFrom(node.get(idx), tokens, pos + 1);
    }

    // Otherwise treat token as a field name (may include bracket indices: base[0][1]…)
    String token = unescapePointerToken(raw);
    int firstBracket = token.indexOf('[');
    String base = firstBracket >= 0 ? token.substring(0, firstBracket) : token;

    JsonNode cur = node;
    if (!base.isEmpty()) {
        cur = cur.path(base);
        if (cur.isMissingNode() || cur.isNull()) return MissingNode.getInstance();
    }

    // Apply bracket indices sequentially
    int i = firstBracket;
    while (i >= 0 && !cur.isMissingNode() && !cur.isNull()) {
        int close = token.indexOf(']', i);
        if (close < 0) return MissingNode.getInstance(); // malformed

        String idxStr = token.substring(i + 1, close).trim();
        if (!isInteger(idxStr)) return MissingNode.getInstance();
        int idx = Integer.parseInt(idxStr);

        if (!cur.isArray() || idx < 0 || idx >= cur.size()) return MissingNode.getInstance();
        cur = cur.get(idx);

        i = token.indexOf('[', close + 1);
    }

    return resolveFrom(cur, tokens, pos + 1);
}

private static boolean isInteger(String s) {
    if (s == null || s.isEmpty()) return false;
    int i = 0, n = s.length();
    char c0 = s.charAt(0);
    if (c0 == '-' || c0 == '+') { if (n == 1) return false; i = 1; }
    for (; i < n; i++) { char c = s.charAt(i); if (c < '0' || c > '9') return false; }
    return true;
}

private static String unescapePointerToken(String tok) {
    // JSON Pointer unescape (~1 -> '/', ~0 -> '~')
    return tok.replace("~1", "/").replace("~0", "~");
}



public static String extractText(JsonNode root, FieldMapping fieldMapping) {
    String path = fieldMapping.getSourcePointer();
    JsonPointer pointer = fieldMapping.getCompiledSourcePointer();

    // Use our custom resolver — it skips root.at() if '*' is present
    JsonNode n = resolve(root, path, pointer);

    return (n.isMissingNode() || n.isNull()) ? null : n.asText();
}
