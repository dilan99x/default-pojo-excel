@Service
@RequiredArgsConstructor
public class CRRSService {

  private final ObjectMapper mapper; // only for JsonFactory
  private final AccountDetailsProvider accountDetailsProvider;      // returns String JSON
  private final AccountHolderDetailsProvider accountHolderProvider; // returns String JSON

  public void writeRssResponse(OutputStream os,
                               CasaAccountSummaryRequest req,
                               HttpHeaders headers) throws IOException {
    final String aJson = accountDetailsProvider.getAccountDetailsJson(req, headers);
    final String bJson = accountHolderProvider.getAccountHolderListJson(req, headers);

    final JsonFactory jf = mapper.getFactory();
    try (JsonGenerator g = jf.createGenerator(os)) {
      g.writeStartObject();

      // data: [ ...A.data..., {"customerInfo":{cin,cinSuffix}} ]
      g.writeFieldName("data");
      g.writeStartArray();

      copyEachArrayElement(jf, g, aJson, "data");

      // NEW: pass the requested account number so we can match productReferenceNumber in B
      writeCustomerInfoElement(jf, g, bJson, req.getSourceAccountNumber());

      g.writeEndArray();

      // error: copy from A.error (or [])
      g.writeFieldName("error");
      if (!copyWholeArray(jf, g, aJson, "error")) {
        g.writeStartArray(); g.writeEndArray();
      }

      g.writeEndObject();
      g.flush();
    }
  }

  private void copyEachArrayElement(JsonFactory jf, JsonGenerator g, String srcJson, String fieldName) throws IOException {
    try (JsonParser p = jf.createParser(srcJson)) {
      while (p.nextToken() != null) {
        if (p.currentToken() == JsonToken.FIELD_NAME && fieldName.equals(p.getCurrentName())) {
          if (p.nextToken() == JsonToken.START_ARRAY) {
            while (p.nextToken() != JsonToken.END_ARRAY) {
              g.copyCurrentStructure(p);
            }
          }
          return;
        }
      }
    }
  }

  private boolean copyWholeArray(JsonFactory jf, JsonGenerator g, String srcJson, String fieldName) throws IOException {
    try (JsonParser p = jf.createParser(srcJson)) {
      while (p.nextToken() != null) {
        if (p.currentToken() == JsonToken.FIELD_NAME && fieldName.equals(p.getCurrentName())) {
          JsonToken t = p.nextToken();
          if (t == JsonToken.START_ARRAY) {
            g.copyCurrentStructure(p);
            return true;
          } else if (t == JsonToken.VALUE_NULL) {
            g.writeStartArray(); g.writeEndArray();
            return true;
          } else {
            g.writeStartArray(); g.writeEndArray();
            return true;
          }
        }
      }
      return false;
    }
  }

  /**
   * Parse B:
   *   - go to root.data[]
   *   - choose item with productReferenceNumber == targetAcct (else first item)
   *   - from its accountHolders[], pick jointAccountOrder==1 else first holder
   *   - write: { "customerInfo": { "cin": "...", "cinSuffix": "..." } }
   */
  private void writeCustomerInfoElement(JsonFactory jf, JsonGenerator g, String bJson, String targetAcct) throws IOException {
    String fallbackCin = null, fallbackSuffix = null;
    String matchCin = null, matchSuffix = null;
    boolean sawAnyHolder = false;
    boolean foundMatchItem = false;

    try (JsonParser p = jf.createParser(bJson)) {
      // seek "data" array
      while (p.nextToken() != null) {
        if (p.currentToken() == JsonToken.FIELD_NAME && "data".equals(p.getCurrentName())) {
          if (p.nextToken() != JsonToken.START_ARRAY) break;

          // iterate items in data[]
          while (p.nextToken() == JsonToken.START_OBJECT) {
            String thisPrn = null;
            // temp holder picks for this item
            String firstCin = null, firstSuffix = null;
            String primaryCin = null, primarySuffix = null;

            // read one item object
            while (p.nextToken() != JsonToken.END_OBJECT) {
              if (p.currentToken() != JsonToken.FIELD_NAME) { p.skipChildren(); continue; }
              String name = p.getCurrentName();
              JsonToken vt = p.nextToken();

              if ("productReferenceNumber".equals(name) && vt == JsonToken.VALUE_STRING) {
                thisPrn = p.getValueAsString();
              } else if ("accountHolders".equals(name) && vt == JsonToken.START_ARRAY) {
                // iterate holders
                boolean firstAssigned = false;
                while (p.nextToken() == JsonToken.START_OBJECT) {
                  String hCin = null, hSuffix = null;
                  Integer order = null;

                  while (p.nextToken() != JsonToken.END_OBJECT) {
                    if (p.currentToken() != JsonToken.FIELD_NAME) { p.skipChildren(); continue; }
                    String hn = p.getCurrentName();
                    JsonToken hvt = p.nextToken();
                    if ("cin".equals(hn) && hvt == JsonToken.VALUE_STRING) hCin = p.getValueAsString();
                    else if ("cinSuffix".equals(hn) && hvt == JsonToken.VALUE_STRING) hSuffix = p.getValueAsString();
                    else if ("jointAccountOrder".equals(hn) && hvt.isNumeric()) order = p.getIntValue();
                    else p.skipChildren();
                  }

                  if (!firstAssigned) {
                    firstCin = hCin; firstSuffix = hSuffix; firstAssigned = true;
                  }
                  if (order != null && order == 1) {
                    primaryCin = hCin; primarySuffix = hSuffix;
                  }
                }
                // array end reached
                sawAnyHolder = sawAnyHolder || firstCin != null || primaryCin != null;
              } else {
                p.skipChildren();
              }
            } // end item object

            // pick holder for this item
            String chosenCin = (primaryCin != null ? primaryCin : firstCin);
            String chosenSuffix = (primaryCin != null ? primarySuffix : firstSuffix);

            // remember first itemâ€™s pick as global fallback
            if (!foundMatchItem && fallbackCin == null && chosenCin != null) {
              fallbackCin = chosenCin; fallbackSuffix = chosenSuffix;
            }

            // if this item matches target account, store and stop scanning further
            if (!foundMatchItem && targetAcct != null && targetAcct.equals(thisPrn) && chosenCin != null) {
              matchCin = chosenCin; matchSuffix = chosenSuffix; foundMatchItem = true;
              // we can break out of the data[] loop by skipping remaining elements
              // but Jackson streaming requires consuming the array properly; so just continue
            }
          } // end while items
          break; // done with data[]
        }
      }
    }

    // choose best available
    String outCin = (matchCin != null ? matchCin : fallbackCin);
    String outSuffix = (matchSuffix != null ? matchSuffix : fallbackSuffix);

    // Only write if we actually found a holder with a CIN
    if (sawAnyHolder && outCin != null && !outCin.isEmpty()) {
      g.writeStartObject();
      g.writeFieldName("customerInfo");
      g.writeStartObject();
      g.writeStringField("cin", outCin);
      if (outSuffix != null && !outSuffix.isEmpty()) {
        g.writeStringField("cinSuffix", outSuffix);
      }
      g.writeEndObject();
      g.writeEndObject();
    }
  }
}
