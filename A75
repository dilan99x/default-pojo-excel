private FieldMapping extractPnsProductCode(MappingConfig config) {
    final String target = acctNumberTransformationConfig.getProductCode();

    for (FieldMapping field : config.getMappedFields()) {
        // 1) Keep your current fast-path for plain object pointers
        try {
            if (field.getCompiledSourcePointer() != null) {
                String property = field.getCompiledSourcePointer().getMatchingProperty();
                if (target.equals(property)) {
                    return field;
                }
            }
        } catch (Exception ignore) {
            // Some compiled pointers (array/wildcard) may not support getMatchingProperty()
            // Fall back to parsing the pointer string.
        }

        // 2) Fallback: inspect the pointer string and compare the *last meaningful token*
        String pointer = resolvePointerString(field);
        if (pointer == null) continue;

        String last = lastMeaningfulToken(pointer);
        if (target.equals(last)) {
            return field;
        }
    }
    return null;
}

/** Get a usable pointer string from FieldMapping, regardless of how it’s stored. */
private String resolvePointerString(FieldMapping field) {
    try {
        if (field.getSourcePointer() != null) {
            return field.getSourcePointer(); // e.g. "/transactionDetails/partTransactionDetails/0/pnsProductCode"
        }
    } catch (Exception ignore) { }

    try {
        if (field.getCompiledSourcePointer() != null) {
            return field.getCompiledSourcePointer().toString(); // most impls return JSON-pointer-like string
        }
    } catch (Exception ignore) { }

    return null;
}

/**
 * Returns the last non-index, non-wildcard token of a JSON-pointer-like path.
 * Examples:
 *  "/a/b/c" -> "c"
 *  "/a/b/0/pnsProductCode" -> "pnsProductCode"
 *  "/a/*/pnsProductCode"   -> "pnsProductCode"
 *  "a/b/c"                 -> "c"
 *  "/a/b/0"                -> "b" (steps back from trailing array index)
 */
private String lastMeaningfulToken(String pointer) {
    if (pointer == null || pointer.isEmpty()) return null;

    String[] parts = pointer.split("/"); // works for both "/a/b" and "a/b"
    // Walk from end to start until we hit a non-index, non-wildcard segment
    for (int i = parts.length - 1; i >= 0; i--) {
        String tok = parts[i];
        if (tok == null || tok.isEmpty()) continue; // skip empty (leading slash)
        if (tok.matches("\\d+") || "*".equals(tok) || "-".equals(tok)) {
            // numeric array index or wildcard — skip upward
            continue;
        }
        // Unescape JSON Pointer tokens (~1 -> '/', ~0 -> '~')
        return tok.replace("~1", "/").replace("~0", "~");
    }
    return null;
}
